{
	"SegTree": {
		"prefix": ["!seg"],
		"body": [
			"struct SegTree {",
			"\tint n;",
			"\tvector<${1:int}> a, seg;",
			"",
			"\tSegTree(int n)",
			"\t\t: n{n}, a(n), seg(4*n, ${2:0}) {}",
			"",
			"\tSegTree(vector<${1:int}> a)",
			"\t\t: n{(int)a.size()}, a{a}, seg(4*n) { build(0, n-1, 1); }",
			"",
			"\t${1:int} combine(${1:int} l, ${1:int} r){",
			"\t\t$0",
			"\t}",
			"",
			"\tvoid build(int l, int r, int pos){",
			"\t\tif (l == r){",
			"\t\t\tseg[pos] = a[l];",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tint mid = l + ((r-l) >> 1);",
			"\t\tbuild(l, mid, pos << 1);",
			"\t\tbuild(mid+1, r, (pos << 1) + 1);",
			"\t\tseg[pos] = combine(seg[pos << 1], seg[(pos << 1)+1]);",
			"\t}",
			"",
			"\tvoid update(int idx, ${1:int} val){ return update(idx, val, 0, n-1, 1); }",
			"\tvoid update(int idx, ${1:int} val, int l, int r, int pos){",
			"\t\tif (l == r){",
			"\t\t\tseg[pos] = a[idx] = val;",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tint mid = l + ((r-l) >> 1);",
			"\t\tif (idx <= mid)",
			"\t\t\tupdate(idx, val, l, mid, pos << 1);",
			"\t\telse",
			"\t\t\tupdate(idx, val, mid+1, r, (pos << 1) + 1);",
			"\t\tseg[pos] = combine(seg[pos << 1], seg[(pos << 1)+1]);",
			"\t}",
			"",
			"\t${1:int} query(int l, int r){ return query(l, r, 0, n-1, 1); }",
			"\t${1:int} query(int ql, int qr, int l, int r, int pos){",
			"\t\tif (qr < l || r < ql)",
			"\t\t\treturn ${2:0};",
			"\t\tif (ql <= l && r <= qr)",
			"\t\t\treturn seg[pos];",
			"\t\tint mid = l + ((r-l) >> 1);",
			"\t\treturn combine(query(ql, qr, l, mid, pos << 1), query(ql, qr, mid+1, r, (pos << 1)+1));",
			"\t}",
			"};"
		],
		"description": "Segment Tree for dynamic range queries"
	}
}